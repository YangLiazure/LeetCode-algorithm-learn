"""
判断一道题目需要用到贪心算法，往往比具体使用贪心算法更难
贪心算法的思想就是保证每次操作都是最优，从而使得最后得到的结果也是最优解
    贪心的使用策略往往具有着从局部到整体的逐步递进过程

"""
// 455. Assign Cookies、

"""
题目：
   有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个饱腹度。每个孩子只能
吃一个饼干，且只有饼干的饱腹度不小于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少
孩子可以吃饱。
"""

"""
题解：
  根据题目分析，有两个数组，分别代表着孩子的饥饿度和饼干的饱腹度，我们需要找到最多能有多少个孩子能够吃饱。
很容易想到，要想让最多的孩子吃饱，应该从饥饿度较低的孩子出发，因为他最容易吃饱，并且尽量分给他较小饱腹度的饼干，
便于剩下饱腹度较大的饼干能够满足饥饿度大的孩子。
  那么我们的贪心策略就是：遍历饥饿度小到饥饿度大的孩子，分别给其分配最小的饱腹度饼干。

贪心策略中 我们往往需要对涉及到的数组等按照一定的规则进行排序，
这里显然是对孩子、饼干分别从小到大去排序，接下来实现的过程应该是这样的：
因为要找到最多满足的孩子，所以最多能够满足孩子的个数不超过饼干个数，这里我们应该是遍历饼干 同时按照条件遍历孩子
如果当前饼干能够满足孩子 则移动饼干 并看下一个孩子 如果不能满足这个孩子 我们还是要移动饼干 如果后面的饼干都不能满足当前孩子
那后面的孩子更不会满足。
这里的贪心策略就是用最小的饼干满足最低饥饿感的孩子。

"""
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());//排序
        sort(s.begin(),s.end());
        int g_size = g.size(), s_size = s.size();
        int g_i = 0 , s_i = 0;
        while(g_i<g_size && s_i<s_size) // 遍历
        {
            if(g[g_i]<=s[s_i]) //如果当前饼干能满足该孩子 孩子++
            {
                ++g_i;
            }
            ++s_i;// 相当于遍历饼干
        }
        return g_i;    //返回的是被满足孩子的数目
    }
};