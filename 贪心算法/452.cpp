、// 452 用最少的箭引爆气球

本题目和最多不重叠区间很像，但是又存在不同。
关键是如何从题目中找到隐藏的贪心策略，既然我们需要用最少的箭引爆所有气球，那么我们的箭的位置应该是每个区间的右结尾
如果有别的区间的左区间小于我们选定的射箭位置的右区间 那么该气球就能够被引爆

我们需要考虑的问题是： 选取哪一个区间的右结尾的问题。我们关心的是一只箭能够引爆更多的气球，那显然，选择较小的右区间更好，因为较小的右区间
和别的区间更可能存在交集。（如果想不明白 我们反过来想 如果我们选择大的右区间 那该位置只能引爆该位置的一个气球）

所以我们要选择 尽量小的右区间作为射箭位置 这里又是一个排序 即按照从小到大的右区间进行排序 第一支箭放在第一个区间的右边界
对于 区间左边界小于射箭位置的 都被引爆了 对于剩下气球 实际上我们可以想象成 原本所有气球的一种特殊情况（本质就是气球数量不同）
所以下一个射箭位置仍然是最小右边界区间位置 即上一个射箭位置没有被引爆的气球的右边界
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
       sort(points.begin(),points.end(),[](vector<int>&a,vector<int>&b) {return a[1]<b[1];});
       // 贪心策略 首先第一步仍然是先对区间进行排序 按照每个区间的右区间大小进行排序
       // 分析策略 我们的箭应该射在哪里才能尽可能射到多的气球 毫无疑问 箭必然是要位于区间的右区间
       int arrows = 1;  
       int arrow_pos = points[0][1]; // 第一支箭 位于第一个元素的右区间处

       // 遍历数组元素的左区间 如果区间的左区间小于我们设定的arrow_pos 那这个气球就能够引爆 我们就不需要用多的箭去射爆
       for(int i =1;i<points.size();i++)
       {
        // 而什么时候我们才需要新的位置的箭呢？ 这里就是贪心策略的体现 在没有射爆的气球中 选择第一个没有被射爆的的气球右区间作为新的射箭位置
            if(points[i][0]>arrow_pos) //无法引爆的气球 我们选择该气球右边界作为新的射箭位置
            {
                arrows++;
                arrow_pos = points[i][1]; //更新 继续循环 直到遍历所有气球
            }
       }
       return arrows;
    }
};