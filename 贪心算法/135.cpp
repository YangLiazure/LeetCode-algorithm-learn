// 135. Candy

"""
题目：
    一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一
个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果。所
有孩子至少要有一个糖果。求解最少需要多少个糖果。

"""
"""
题解：
    该题目的贪心策略并不是很显著，但总体可以看成两步，即对于每个孩子而言，依据规则对于每个孩子我们先去满足左侧的规则。
	再去满足右侧的规则。
	把所有孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加；
	再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右\
	边孩子的糖果数加。通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。

"""
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int>candies(n,1);
        for(int i = 0;i<n-1;++i)
        {
            if(ratings[i]<ratings[i+1])
            {
                candies[i+1] = candies [i]+1;
            }
        }
        for(int i = n-1;i>0;--i)
        {
            if(ratings[i]<ratings[i-1])
            {
                candies[i-1] = max(candies[i]+1,candies[i-1]);
            }
        }
        return accumulate(candies.begin(),candies.end(),0);
    }
};

// 贪心策略是分别比较一侧的糖果数量 每次遍历只更新相邻一侧的大小关系