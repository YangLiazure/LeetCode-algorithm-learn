// 435.Non-overlapping Intervals

给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。

Input: [[1,2], [2,4], [1,3]]
Output: 1

在这个样例中，我们可以移除区间[1,3]，使得剩余的区间 [[1,2], [2,4]] 互不重叠

题解：
    首先明确区间问题实际上都是很经典的使用贪心策略解决的问题。要求移除最少的区间，使得剩下的区间不重叠，就等价于尽量多保留不重叠的区间。
	我们应该怎么考虑尽量多的区间不重叠的区间呢？选择的区间结尾越小，预留给其他区间的空间就会越大，进而就能够保留更多的区间。因此，我们采取的
	贪心策略应该是：保留末尾小的且不相交的区间
	
实现方法：
    根据题解思路，我们首先需要对所给区间进行排序，这里应使用lambda函数，得到按照区间结尾升序排列的区间。下一步是如何实现我们的贪心策略。
	显然地，如果区间重叠了，我们面临着移除哪一个的问题。这里又回到了一开始的贪心策略：始终保留那个结束点最小的区间，因为这个区间给后面的
	区间留下的空间最大，从而最小化了未来重叠的可能性。
	所以，当我们实现对所有区间进行排序之后，遍历所有区间，如果某个区间和其后面的区间重叠，那么我们应该舍弃后面的区间。
	
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){return a[1]<b[1];});
    // lambda 函数 对intervals进行排序 排序的准则是按照数组中每个元素区间的末尾元素大小进行排序
    // 经过排序之后 首先第一个区间元素 是不能被移除的 将其纳入到最大不重叠区间
    // 接下来看第二个元素 我们需要对其进行判断是否重叠 如果重叠了 我们应该移除哪一个
    //始终保留那个结束点最小的区间，因为这个区间给后面的区间留下的空间最大，从而最小化了未来重叠的可能性。

    int removed = 0 , prev_end = intervals[0][1];
    for(int i = 1 ; i<intervals.size(); ++i)
    {
        if(intervals[i][0] < prev_end)
        {
            ++removed;
        }
       else{
        prev_end = intervals[i][1];
       }
    }
    return removed;
    }
};