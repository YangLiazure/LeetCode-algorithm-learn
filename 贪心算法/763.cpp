// 763 划分字母区间

给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 "ababcc" 能够被分为 ["abab", "cc"]，
但类似 ["aba", "bcc"] 或 ["ab", "ab", "cc"] 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。

/****************************************/
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。

题解：
    首先理解题意非常关键 这实际上也是我们写代码的依据。我们要清楚是怎么进行划分的 建议先自己用较短的字符串进行模拟。
    例如对于上面的字符串，从第一个字符开始a，依据题意，我们应该选择该字符a出现的最后一个位置为划分。但是这样真的合理吗？我们要考虑的是当前
	划分对于该子字符串中所有字符是否也合理，例如，如果依据第一个字符划分后，end = 3 。 但对于第二个字符其最后出现的位置是end = 8 .显然，
	我们划分的位置就要变为8.
	因此，大致的一个思路就是，先根据第一个字符确定划分位置，然后看该划分片段内的所有字符的最后出现位置，是否超出当前划分。
	但是上面仅仅是思路，还要转化为具体可行的代码，并且我们要找到的是划分后的字符串的长度。
	回到前面的思路，如果子字符串内超出了第一个字符的end 那我们就要重新划分，即按照第二个字符的end进行划分....依次进行，直到遍历到end 内所有字符的end都不大于
	当前的end值。
	代码思路很明显了，对于每一个字符，我们先确定其最后出现的位置。然后end初始化为第一个字符的end，继续遍历，如果当前字符i的end大于当前end，更新end。遍历过程中如果i=end
	就说明符合要求，可以划分，返回字符串长度。接着将end初始化为划分后的下一个字符串的首字符的end...直到遍历整个字符串

class Solution {
public:
    vector<int> partitionLabels(string s) {
        
        // 第一步：构建哈希表（或数组），记录每个字符最后一次出现的位置
        int last_occurrence[26];
        
        // 遍历字符串 s，填充 last_occurrence 数组
        //贪心算法
        for(int i = 0 ; i<s.size();++i)
        {
            last_occurrence[s[i]-'a'] = i;
        }
		
        vector<int>result;
        int start = 0;
        int end = 0;
        // 思路是遍历字符串 首先确定第一个字符的最后一个出现的位置end 然后看当前start end中所有字符的最后一次出现位置是否大于当前end 
        // 更换其思路就是 遍历字符根据一定条件更新end 如果i == end 说明当前字符串段已经符合要求 
        for(int i = 0 ;i<s.size();++i){
            if(last_occurrence[s[i]-'a']>end){
                end = last_occurrence[s[i]-'a']; //如果当前字符最后一次出现的位置大于当前的end 更新end
            }
            if(i==end){ //如果i=end 说明当前字符串段已经符合要求
                result.push_back(end-start+1); //返回字符串长度
                start = end+1; 
            }
        }
        return result;
    }
};